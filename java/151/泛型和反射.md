# 泛型和反射
泛型实际上就是将参数赋值给泛型的上限类，然后在赋值给指定泛型的时候，自动进行强制转换，也是一种语法糖。
### 93、java的泛型是类型擦除的
java泛型的引入加强了参数类型的安全性，减少了类型的转换，与c++中的模板（Template）比较类似，但是java的泛型在编译期有效，在运行期被删除。如果重载方法的参数分别为List<String>和List<Integer>，编译会出错。java在编译后，所有的泛型都会做相应的转化，转化规则如下：
* List<String>、List<Integer>、List<T>擦除后的类型为List；
* List<String>[]擦除后的类型为List[]；
* List<T extends Serializable & Cloneable>擦除后为List<Serializable>;
  
* 泛型的class对象是相同的；
* 泛型数组初始化时不能声明泛型类型。List<String>[] listArray = new List<String>[];编译通不过。原因：可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操作，List<Object>[]与List<String>就是一回事了，编译器拒绝如此声明；
* instanceof不允许存在泛型参数，因为泛型类型被擦除了。例如:下面代码不能用过编译。
```
List<String> list = new ArrayList<String>();
System.out.println(list instanceof List<String>);
```
### 94、不能初始化泛型参数和数组
泛型类型在编译期被擦除，我们在类初始化时将无法获得初始化的具体参数。T t = new T();编译会出错。而List<String> list = new ArrayList<String>();编译不会报错。注意区别：ArrayList本质上是Object数组，泛型List会在赋值和取值的时候进行类型转换。  
如果确实需要泛型数组，可以这样处理：
```
class Foo<T>{
  private T t;
  private T[] tArray;
  private List<T> list = new ArrayList<T>();
  public Foo(){
    try{
      Class<?> tType = Class.forName("");
      t = (T)tType.newInstance();
      tArray = (T[])Array.newInstance(tType,5);
    catch (Exception e){
      e.printStackTrace();
    }
  }
}
```
这样运行期间就不会有问题了，剩下的问题在于怎么在运行期键获得T的类型，也就是tType参数，一般情况下泛型参数是无法获取的，不过在客户端调用的时候多传一个T类型的class就会解决问题。  
类的成员变量是在类初始化前初始化的，所以要求在初始化的前它必须具有明确的类型。否则只能声明，不能初始化。
### 95、强制声明泛型的实际类型
编译器在不确定泛型的实际参数类型的时候，会把泛型转为Object类。编译器在发现方法的多个参数的实际类型不一致时就会直接确定泛型类型是Object，而不会去追索元素类的公共父类。泛型方法可以在调用时声明泛型类型：
```
List<Number> list3 = ArrayUtils.<Number>asList(1,2,3.1);
```
通过强制声明泛型参数类型，我们可以明确泛型方法的输入、输出参数类型。在无法从代码中推断出泛型类型的情况下，就可以强制声明泛型类型。
### 96、不同的场景使用不同的泛型通配符
java泛型支持通配符，可以使用"?"表示任何类，加上extends表示一个类或借口的子类型，家还是那个super表示某一个类或借口的父类型。  
* 泛型结构只参与读操作时限定上界（extends）
* 泛型结构只参与写操作时限定上界（super）
JDK的Collections.copy方法就很好地体现了这一点。
